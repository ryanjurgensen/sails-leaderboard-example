(function(){

	// Map a few pressFoo events automatically
	pressFoo(27,'pressEscape');
	pressFoo(13,'pressEnter');
	
	// Map global pressFoo events
	pressFoo(27,'gPressEscape',true,"keydown");
	pressFoo(13,'gPressEnter',true,'keydown');
	
	
	// Enable public access to this method for registering more events later
	$.pressFoo = pressFoo;
	
	// Map a custom keypress event
	function pressFoo(keyCode,handlerName,globalScope,eventSrc) {
		eventSrc = eventSrc || "keyup";
		
		var pressEvent = function (origTarget,keyCode,handlerName) {
			return function(e) {
				e.stopPropagation();
				var pressedkeycode = e.keyCode || e.which;
				if(pressedkeycode == keyCode) {
					e.preventDefault();
					origTarget.triggerHandler( handlerName,e );
				}
			}
		}
		
		// Add our new event to jQuery
		// (handlerName is the name of the new event)
		$.event.special[handlerName] = {
		
			// This method gets called the first time this event
			// is bound to THIS particular element. It will be
			// called once and ONLY once for EACH element.
			setup: function( eventData, namespaces ){
				var target = globalScope ? $(document) : $(this),
				origTarget = $(this),
				dataKeyName = '_pressFooBound'+keyCode;

				// Bind the event handler that we are going
				// to need to make sure this event fires correctly.
				var eventHandler = pressEvent(origTarget,keyCode,handlerName);
				if (origTarget.data(dataKeyName)) {			// Clear out existing keyup or keydown events
					target.unbind(eventSrc,eventHandler);
					origTarget.data(dataKeyName,false);
				}
				target.bind(eventSrc, eventHandler);
				origTarget.data(dataKeyName,eventHandler);
			

				// Return void as we don't want jQuery to use the
				// native event binding on this element.
				return;
			},

			// This method gets called when this event us unbound
			// from THIS particular element.
			teardown: function( namespaces ) {

				var target = globalScope ? $(document) : $(this),
				origTarget = $(this),
				dataKeyName = '_pressFooBound'+keyCode;

				// Bind the event handler that we are going
				// to need to make sure this event fires correctly.
				target.unbind( eventSrc, origTarget.data(dataKeyName));
				origTarget.data(dataKeyName,false);

				// Return void as we don't want jQuery to use the
				// native event binding on this element.
				return;
			}
		}
	}

})();

/***
 * 
var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
jQuery.fn.triggerHandlerSpecial = function( type, data ) {
	if ( this[0] ) {
		return jQuery.event.triggerSpecial( type, data, this[0], true );
	}
}; 
jQuery.event.triggerSpecial = function( event, data, elem, onlyHandlers ) {
	// Don't do events on text and comment nodes
	if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
		return;
	}

	// Event object or event type
	var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
	type = event.type || event,
	namespaces = [];

	// focus/blur morphs to focusin/out; ensure we're not firing them right now
	if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
		return;
	}

	if ( type.indexOf( "!" ) >= 0 ) {
		// Exclusive events trigger only for the exact event (no namespaces)
		type = type.slice(0, -1);
		exclusive = true;
	}

	if ( type.indexOf( "." ) >= 0 ) {
		// Namespaced trigger; create a regexp to match event type in handle()
		namespaces = type.split(".");
		type = namespaces.shift();
		namespaces.sort();
	}

	if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
		// No jQuery handlers for this event type, and it can't have inline handlers
		return;
	}

	// Caller can pass in an Event, Object, or just an event type string
	event = typeof event === "object" ?
		// jQuery.Event object
	event[ jQuery.expando ] ? event :
		// Object literal
	new jQuery.Event( type, event ) :
		// Just the event type (string)
	new jQuery.Event( type );

	event.type = type;
	event.isTrigger = true;
	event.exclusive = exclusive;
	event.namespace = namespaces.join( "." );
	event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
	ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

	// Handle a global trigger
	if ( !elem ) {

		// TODO: Stop taunting the data cache; remove global events and always attach to document
		cache = jQuery.cache;
		for ( i in cache ) {
			if ( cache[ i ].events && cache[ i ].events[ type ] ) {
				jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
			}
		}
		return;
	}

	// Clean up the event in case it is being reused
	event.result = undefined;
	if ( !event.target ) {
		event.target = elem;
	}

	// Clone any incoming data and prepend the event, creating the handler arg list
	data = data != null ? jQuery.makeArray( data ) : [];
	//	data.unshift( event );

	// Allow special events to draw outside the lines
	special = jQuery.event.special[ type ] || {};
	if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
		return;
	}

	// Determine event propagation path in advance, per W3C events spec (#9951)
	// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
	eventPath = [[ elem, special.bindType || type ]];
	if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

		bubbleType = special.delegateType || type;
		cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
		for ( old = elem; cur; cur = cur.parentNode ) {
			eventPath.push([ cur, bubbleType ]);
			old = cur;
		}

		// Only add window if we got to document (e.g., not plain obj or detached DOM)
		if ( old === (elem.ownerDocument || document) ) {
			eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
		}
	}

	// Fire handlers on the event path
	for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

		cur = eventPath[i][0];
		event.type = eventPath[i][1];

		handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
		if ( handle ) {
			handle.apply( cur, data );
		}
		// Note that this is a bare JS function and not a jQuery handler
		handle = ontype && cur[ ontype ];
		if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
			event.preventDefault();
		}
	}
	event.type = type;

	// If nobody prevented the default action, do it now
	if ( !onlyHandlers && !event.isDefaultPrevented() ) {

		if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
			!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

			// Call a native DOM method on the target with the same name name as the event.
			// Can't use an .isFunction() check here because IE6/7 fails that test.
			// Don't do default actions on window, that's where global variables be (#6170)
			// IE<9 dies on focus/blur to hidden element (#1486)
			if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

				// Don't re-trigger an onFOO event when we call its FOO() method
				old = elem[ ontype ];

				if ( old ) {
					elem[ ontype ] = null;
				}

				// Prevent re-triggering of the same event, since we already bubbled it above
				jQuery.event.triggered = type;
				elem[ type ]();
				jQuery.event.triggered = undefined;

				if ( old ) {
					elem[ ontype ] = old;
				}
			}
		}
	}

	return event.result;
}


 */